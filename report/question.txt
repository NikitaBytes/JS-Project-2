*** Контрольные вопросы ***

*** Какое значение возвращает функция fetch? ***

В контексте веб-разработки, функция fetch() используется для отправки 
запросов к серверу и получения ответов. Она возвращает объект Promise, 
который разрешается при получении ответа от сервера. Этот ответ содержит 
объект Response, который в свою очередь может содержать данные, например, 
текстовую информацию или объекты JSON, в зависимости от типа запроса 
и ответа сервера. Если запрос не удалось выполнить из-за сетевых проблем 
или других ошибок, Promise будет отклонён с соответствующим сообщением 
об ошибке.

*** Что представляет собой Promise? ***

Объект Promise в JavaScript представляет собой обёртку для значения, 
которое может быть известно сразу, может стать известным в будущем, 
или никогда не стать известным. Он позволяет работать с асинхронными 
операциями, предоставляя возможность обрабатывать их результаты так, 
как если бы они были синхронными.

*** Какие методы доступны у объекта Promise? ***

Доступные методы для обьекта Promise:

then(onFulfilled, onRejected): Этот метод добавляет обработчики для выполненного (resolved) или отклонённого (rejected) состояния Promise. Первый аргумент onFulfilled вызывается, когда Promise успешно завершается, а второй аргумент onRejected вызывается, когда Promise завершается с ошибкой. Оба аргумента являются необязательными.
catch(onRejected): Этот метод добавляет обработчик только для отклонённого (rejected) состояния Promise. Он эквивалентен .then(undefined, onRejected).
finally(onFinally): Этот метод добавляет обработчик, который будет выполнен независимо от того, успешно ли завершилась операция или произошла ошибка.
all(iterable): Этот метод возвращает Promise, который разрешается, когда все Promise в передаваемом итерируемом объекте разрешаются, или отклоняется, когда один из Promise в этом объекте отклоняется.
race(iterable): Этот метод возвращает Promise, который разрешается или отклоняется сразу, как только один из Promise в передаваемом итерируемом объекте разрешается или отклоняется.
allSettled(iterable): Этот метод возвращает Promise, который разрешается после завершения всех Promise в передаваемом итерируемом объекте, когда они становятся в состояние fulfilled или rejected.
any(iterable): Этот метод возвращает Promise, который разрешается, как только один из Promise в передаваемом итерируемом объекте разрешается. Он игнорирует любые Promise, которые отклоняются, и отклоняется только в случае, если все Promise отклонены.
resolve(value): Этот статический метод возвращает Promise, который разрешается с переданным значением.
reject(reason): Этот статический метод возвращает Promise, который отклоняется с переданной причиной.
Symbol.species: Символ, используемый для создания производных классов Promise.

*** Каковы основные различия между использованием async / await и Promise? ***
Основные различия между использованием async/await и Promise заключаются 
в синтаксисе и удобстве работы с асинхронным кодом:

Синтаксис:
Promise: Использует методы .then() и .catch() для обработки успешного 
выполнения или ошибок соответственно.
async/await: Позволяет писать асинхронный код так, как будто это 
синхронный код, используя ключевые слова async для определения 
асинхронной функции и await для приостановки выполнения кода 
до завершения асинхронной операции.
Читаемость и удобство:
async/await: Позволяет писать код более линейно и понятно, что облегчает 
его чтение и отладку. Он больше похож на синхронный код, что делает его 
более привлекательным для многих разработчиков.
Promise: Может быть более сложным для понимания, особенно при цепочке 
нескольких вызовов .then(), особенно если их много.
Обработка ошибок:
Promise: Обработка ошибок осуществляется через метод .catch() или 
внутри блока .then(null, errorCallback).
async/await: Обработка ошибок может быть выполнена с помощью блока 
try/catch, что делает код более структурированным и позволяет обрабатывать ошибки более естественным способом, как в синхронном коде.
Вложенные вызовы:
Promise: Вложенные вызовы .then() могут привести к образованию "цепочек" 
промисов, что может сделать код менее читаемым (концепция известна 
как "callback hell").
async/await: Позволяет избежать "callback hell" и делает код более 
линейным, особенно при использовании блока try/catch.
В целом, async/await предоставляет более удобный и легкий для понимания 
способ написания асинхронного кода, особенно при работе с промисами.